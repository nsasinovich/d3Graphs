<!DOCTYPE html>
<meta charset="utf-8">
<style>
    .line {
        fill: none;
        stroke: steelblue;
        stroke-width: 3px;
    }

    .axis path,
    .axis line {
        fill: none;
        stroke: #ddd;
        shape-rendering: crispEdges;
    }
</style>
<svg width="1024" height="768"></svg>
<script src="http://d3js.org/d3.v4.min.js"></script>
<script>
    const maxScore = 360;

    var svg = d3.select("svg"),
        margin = {
            top: 20,
            right: 80,
            bottom: 30,
            left: 50
        },
        width = svg.attr("width") - margin.left - margin.right,
        height = svg.attr("height") - margin.top - margin.bottom,
        g = svg.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var x = d3.scaleLinear().range([0, width]),
        y = d3.scaleLinear().range([height, 0]),
        z = d3.scaleOrdinal(d3.schemeCategory10);

    var bisectYear = d3.bisector(d => d.year).left;

    var line = d3.line()
        .curve(d3.curveMonotoneX)
        .x(function(d) {
            return x(d.year);
        })
        .y(function(d) {
            return y(d.score);
        });

    d3.csv("data.csv", type, function(error, data) {
        if (error) throw error;

        var specialties = data.columns.slice(1).map(function(id) {
            return {
                id: id,
                values: data.map(function(d) {
                    return {
                        year: d.year,
                        score: d[id]
                    };
                })
            };
        });


        x.domain([
            d3.min(specialties, function(c) {
                return d3.min(c.values, function(d) {
                    return d.year;
                });
            }),
            d3.max(specialties, function(c) {
                return d3.max(c.values, function(d) {
                    return d.year;
                });
            })
        ]);

        y.domain([
            d3.min(specialties, function(c) {
                return d3.min(c.values, function(d) {
                    return d.score;
                });
            }),
            maxScore
        ]);

        z.domain(specialties.map(function(c) {
            return c.id;
        }));

        g.append("g")
            .attr("class", "axis axis--x")
            .attr("transform", "translate(0," + height + ")")
            .call(d3.axisBottom(x).ticks(data.length - 1).tickSize(-height).tickFormat(d3.format("d")));

        g.append("g")
            .attr("class", "axis axis--y")
            .call(d3.axisLeft(y).ticks(9).tickSize(-width))
            .append("text")
            .attr("y", 0)
            .attr("dy", "-1em")
            .attr("fill", "#000")
            .text("score");

        var specialtity = g.selectAll(".specialtity")
            .data(specialties)
            .enter().append("g")
            .attr("class", "specialtity");

        specialtity.append("path")
            .attr("class", "line")
            .attr("d", function(d) {
                return line(d.values);
            })
            .style("stroke", function(d) {
                return z(d.id);
            });

        specialtity.append("text")
            .datum(function(d) {
                return {
                    id: d.id,
                    value: d.values[d.values.length - 1]
                };
            })
            .attr("transform", function(d) {
                return "translate(" + x(d.value.year) + "," + y(d.value.score) + ")";
            })
            .attr("x", 3)
            .attr("dy", "0.35em")
            .style("font", "10px sans-serif")
            .text(function(d) {
                return d.id;
            });

        svg.on('mousemove', () => {
            const year = x.invert(d3.event.clientX);
            const index = bisectYear(data, year, 1) - 1;

            const yearData = specialties.map(s => ({
                id: s.id,
                value: s.values[index].score,
                year: +s.values[index].year
            }));

            const hints = g.selectAll('.value-hint').data(yearData, d => d.id + d.year);
        
            hints.enter()
                .append('circle')
                .classed('value-hint', true)
                .attr('cx', d => x(d.year))
                .attr('cy', d => y(d.value))
                .attr('r', 5)
            
            hints.exit().remove();
        })
    });

    function type(d, _, columns) {
        for (var i = 1, n = columns.length, c; i < n; ++i) d[c = columns[i]] = +d[c];
        return d;
    }
</script>
